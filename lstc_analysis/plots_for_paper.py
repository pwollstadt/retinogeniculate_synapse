#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""Generate plots for paper, aggregate results over cell pairs.

Aggregate all relevant measures over cell pairs. Create LATeX tables and
figures. Measures include:

    - TE/AIS results
    - LAIS-LTE correlation coefficient
    - delays
    - PID estimates
    - spike-triggered averages
    - inter-spike intervals
    - AIS/TE by sample size

Note that this script loads results generated by scripts with prefix
'estimate_*' and 'generate_results_*'.
"""
import sys
import pickle
import string
import itertools
import copy as cp
import numpy as np

import scipy.stats as sc
import matplotlib as mlp
import matplotlib.pyplot as plt
import matplotlib.colors as clr

from utils import load_mte_ais_estimates, get_paths, load_local_estimates

# #############################################################################
#
# Global Parameters and Figure Settings
#
# #############################################################################

# Create a spinner as a busy symbol when performing permutation tests
spinner = itertools.cycle(['-', '\\', '|', '/'])
datapath, resultspath, figurepath = get_paths('paths.json')

# List of pairs with significant TE/AIS estimates.
all_pairs = [i for i in range(1, 18)]
all_pairs.remove(5)
N = len(all_pairs)

fig_ext = 'pdf'


def _set_tex_font_params():
    # Set Font style
    plt.rc('text', usetex=False)
    plt.rcParams['mathtext.fontset'] = 'stix'
    plt.rcParams['font.family'] = 'STIXGeneral'


fig_params = {
    'fig_width': 6.0,
    'subplot_height': 2.0,
    'legend_prop': {'family': 'STIXGeneral', 'size': 10}
}

subplot_label_size = 12
axes_linewidth = 0.7
plt.rc('text', usetex=False)
plt.rcParams['mathtext.fontset'] = 'stix'
plt.rcParams['font.family'] = 'STIXGeneral'
plt.rc('axes', titlesize=12, labelsize=12, titleweight='bold',
       linewidth=axes_linewidth)
plt.rc('xtick', labelsize=10, direction='out')
plt.rc('xtick.major', size=2.5, width=axes_linewidth)
plt.rc('ytick', labelsize=10, direction='out')
plt.rc('ytick.major', size=2.5, width=axes_linewidth)
plt.rc('legend', fontsize=10)

# Colors
col_light_gray = 'lightgray'
col_dark_gray = 'darkgray'

# LTE (red) and LAIS (blue)
col_lte_dark = 'indianred'  # alt.: 'firebrick', 'darkred'
col_lte_light = 'salmon'
col_lais_dark = 'steelblue'  # 'darkblue'
col_lais_light = 'lightsteelblue'  # 'slateblue'

# Spike trains, RGC (green) and LGN (purple)
col_rgc_dark = 'darkgreen'
col_rgc_light = 'forestgreen'
col_lgn_dark = 'purple'  # alt.: purple, rebeccapurple, indigo
col_lgn_light = 'thistle'

# PID (green)
col_pid_dark = 'gold'
col_unq_rgc_all_dark = 'darkgray'
col_syn_dark = 'dimgray'
col_unq_lgn_all_dark = '#74c476'
col_shd_dark = '#a1d99b'


def enumerate_subplots(fig_handle, x, y, text_size=12, text_weight='bold'):
    ax_list = fig_handle.axes
    for n, ax in enumerate(ax_list):
        ax.text(x, y, string.ascii_uppercase[n], transform=ax.transAxes,
                size=text_size, weight=text_weight)


# #############################################################################
#
# mTE/AIS results
#
# #############################################################################
def embedding_results():
    print('\nCollection embedding results and writing them to disk')

    # Get IDTxl results to access settings
    mte, ais = load_mte_ais_estimates(resultspath, n_pair=10)

    mte_source_len = np.zeros(N).astype(int)
    mte_target_len = np.zeros(N).astype(int)
    delays_all = np.zeros(N).astype(int)
    ais_past_len = np.zeros(N).astype(int)
    mte_source_lags = np.zeros(mte.settings['max_lag_sources']).astype(int)
    mte_target_lags = np.zeros(mte.settings['max_lag_target']).astype(int)
    ais_source_lags = np.zeros(ais.settings['max_lag']).astype(int)

    for i, n_pair in enumerate(all_pairs):
        mte, ais = load_mte_ais_estimates(resultspath, n_pair)
        delay = int(np.load(resultspath.joinpath(f'pair_{n_pair:02d}_delay.npy')))

        if not mte.get_single_target(1, False)['selected_vars_sources']:
            print('No selected vars for pair {}'.format(n_pair))
            continue
        for var in mte.get_single_target(1, False)['selected_vars_sources']:
            mte_source_lags[var[1]] += 1
        for var in mte.get_single_target(1, False)['selected_vars_target']:
            mte_target_lags[var[1]] += 1
        for var in ais.get_single_process(0, False)['selected_vars']:
            ais_source_lags[var[1]] += 1
        mte_source_len[i] = len(
            mte.get_single_target(1, False)['selected_vars_sources'])
        mte_target_len[i] = len(
            mte.get_single_target(1, False)['selected_vars_target'])
        delays_all[i] = delay
        ais_past_len[i] = len(
            ais.get_single_process(0, False)['selected_vars'])

    np.save(resultspath.joinpath('all_pairs_delays'), delays_all)
    np.savez(
        resultspath.joinpath('all_pairs_embedding_parameters'),
        delays=delays_all,
        mte_source_lags=mte_source_lags,
        mte_target_lags=mte_target_lags,
        ais_source_lags=ais_source_lags,
        ais_past_len=ais_past_len,
        mte_source_len=mte_source_len,
        mte_target_len=mte_target_len
        )

    fig, ax = plt.subplots(nrows=3, figsize=(5.2, 4))
    max_x = 30
    ax[0].bar(np.arange(1, max_x), ais_source_lags[1:max_x], color="#4682b4", edgecolor='black')
    ax[1].bar(np.arange(1, max_x), mte_source_lags[1:max_x], color="#cd5c5c", edgecolor='black', hatch='//')
    ax[2].bar(np.arange(1, max_x), mte_target_lags[1:max_x], color="#cd5c5c", edgecolor='black')
    for a in ax:
        a.set(ylabel='count', xlabel='lag [ms]')
    plt.tight_layout()
    plt.savefig(figurepath.joinpath('all_pairs_lag_distribution.pdf'))
    plt.close()


# #############################################################################
#
# LAIS-LTE CORRELATION
#
# #############################################################################
def lstc_correlation():
    print('\nCalculate LSTC and correlation between LSTC and contribution')
    # Load correlation results
    contribution = np.genfromtxt(datapath.joinpath('contr.csv'), delimiter=',')
    contribution = contribution[np.array(all_pairs)-1]
    c_all = np.zeros(len(all_pairs))
    r_all = np.zeros(len(all_pairs))
    c_pval_all = np.zeros(len(all_pairs))
    r_pval_all = np.zeros(len(all_pairs))
    for i, n_pair in enumerate(all_pairs):
        with open(resultspath.joinpath(f'pair_{n_pair:02d}_correlation.p'), 'rb') as f:
            corr = pickle.load(f)
        # Collect individual results and apply Bonferroni-correction.
        c_all[i] = corr['corrcoef']
        r_all[i] = corr['spearmanr']
        c_pval_all[i] = corr['p_value_c']
        r_pval_all[i] = corr['p_value_r']
    alpha = 0.01
    significant = c_pval_all < alpha/len(all_pairs)
    print(f'Pairs with sign. LSTC (Bonferroni-corrected, a={alpha}):')
    print(f'{np.array(all_pairs)[significant]}\n{c_pval_all[significant]}')
    c = np.corrcoef(contribution[significant], c_all[significant])
    r = sc.spearmanr(contribution[significant], c_all[significant])
    corr_contr = {'pearson_p': c[0, 1],
                  'spearman_r': r[0],
                  'n_permutations': 1000,
                  'pair_id': all_pairs,
                  'c_all': c_all,
                  'c_pval_all': c_pval_all,
                  'r_all': r_all,
                  'r_pval_all': r_pval_all,
                  'contribution': contribution
                  }

    # Calculate correlation with contribution over pairs. Make a copy to use
    # numpy's in-place shuffling.
    contribution_surrogate = cp.copy(contribution[significant])
    perm_dist_c = np.zeros(corr['n_permutations'])
    perm_dist_r = np.zeros(corr['n_permutations'])
    for p in range(corr['n_permutations']):
        # Shuffle LAIS in place
        np.random.shuffle(contribution_surrogate)
        c = np.corrcoef(contribution_surrogate, c_all[significant])
        r = sc.spearmanr(contribution_surrogate, c_all[significant])
        perm_dist_c[p] = c[0, 1]
        perm_dist_r[p] = r[0]
        # Print a busy symbol to the console
        sys.stdout.write(next(spinner))
        sys.stdout.flush()
        sys.stdout.write('\b')

    # Calculate Bonferroni-corrected p-values.
    corr_contr['p_value_c'] = (
        sum(perm_dist_c >= corr_contr['pearson_p']) /
        corr_contr['n_permutations']
    )
    corr_contr['p_value_r'] = (
        sum(perm_dist_r >= corr_contr['spearman_r']) /
        corr_contr['n_permutations']
    )
    print('pearson corr contribution-LSTC r={0:.4f} (p-val: {1:.4f}, spearman r p-val: {2:.4f})'.format(
        corr_contr['pearson_p'], corr_contr['p_value_c'], corr_contr['p_value_r']))

    # Save results
    with open(resultspath.joinpath('all_pairs_correlation_contr.p'), 'wb') as f:
        pickle.dump(corr_contr, f)

    # Plot correlation as scatter plot.
    plt.figure(figsize=(3.5, 2.5))
    plt.subplots_adjust(left=0.2, right=0.9, bottom=0.17, top=0.95, wspace=0.4, hspace=0.4)
    bar_linewidth = axes_linewidth
    contribution = np.array(contribution)
    plt.scatter(contribution[significant], c_all[significant], s=40,
                linewidth=bar_linewidth, color=col_light_gray, edgecolor='k',
                alpha=0.8)
    plt.xlabel('contribution [%]')
    plt.ylabel('LSTC [$c(lAIS, lTE)$]')
    plt.text(-6, 0.25,
             '$c(LSTC, contribution) = {0:.4f}$,\n$p= {1:.4f}$'.format(
                corr_contr['pearson_p'], corr_contr['p_value_c']),
             fontsize=9)

    # Define label-positions for scatter plot
    xy_labels = {}
    for i in range(1, 10):
        xy_labels[str(i)] = (7, -10, False)
    for i in range(10, 18):
        xy_labels[str(i)] = (11, -10, False)

    xy_labels['1'] = (13, -14, True)
    xy_labels['8'] = (10, 4, True)
    xy_labels['7'] = (-8, -1, True)
    xy_labels['9'] = (-6, 1, True)
    xy_labels['10'] = (-5, -8, False)
    xy_labels['12'] = (-8, 1, True)
    # Labels with arrows
    xy_labels['13'] = (14, -15, True)
    xy_labels['2'] = (15, -12, True)

    labels = ['{0}'.format(i) for i in np.array(all_pairs)[significant]]
    for label, x, y in zip(labels, contribution[significant], c_all[significant]):

        if xy_labels[label][2]:
            plt.annotate(
                label,
                xy=(x, y), xytext=(xy_labels[label][0], xy_labels[label][1]),
                textcoords='offset points', ha='right', va='bottom', fontsize=8,
                arrowprops=dict(arrowstyle='-', lw=0.5),
                bbox=dict(pad=0, facecolor="none", edgecolor="none"))
        else:
            plt.annotate(
                label,
                xy=(x, y), xytext=(xy_labels[label][0], xy_labels[label][1]),
                textcoords='offset points', ha='right', va='bottom', fontsize=8)

    plt.xlim([-10, 80])
    plt.ylim([-0.01, 0.30])
    plt.savefig(figurepath.joinpath(f'all_pairs_contr_scatter.{fig_ext}'),
                dpi=400)
    plt.close()


# #############################################################################
#
# PID ESTIMATION
#
# #############################################################################
def plot_pid_all():
    print('\nPlotting PID results')
    _set_tex_font_params()
    delays_all = np.load(resultspath.joinpath('all_pairs_delays.npy'))

    unq_rgc_all = np.zeros(N)
    unq_lgn_all = np.zeros(N)
    shd_all = np.zeros(N)
    syn_all = np.zeros(N)
    te_all = np.zeros(N)

    for i, n_pair in enumerate(all_pairs):
        lte = load_local_estimates(resultspath, n_pair)[0]
        lte = lte[delays_all[i]:]
        with open(resultspath.joinpath(f'pair_{n_pair:02d}_pid.p'), 'rb') as f:
            pid = pickle.load(f)

        unq_rgc_all[i] = pid['unq_s1']
        unq_lgn_all[i] = pid['unq_s2']
        shd_all[i] = pid['shd_s1_s2']
        syn_all[i] = pid['syn_s1_s2']
        te_all[i] = np.mean(lte)

    # Plot Unique + Synergy versus TE as stacked bars
    plt.figure(figsize=(fig_params['fig_width'], fig_params['subplot_height']))
    plt.subplots_adjust(left=0.1, right=0.95, bottom=0.2, top=0.82)
    bar_linewidth = axes_linewidth
    width = 0.35
    space = 0.05
    x_min = 1 - 2 * width
    x_max = N + 4 * width

    rgc_unq_norm = unq_rgc_all / te_all
    syn_norm = syn_all / te_all

    bars_te = plt.bar(np.arange(1, N + 1), te_all / te_all, width,
                      color=col_lte_dark, linewidth=bar_linewidth)
    bars_unq_rgc_all = plt.bar(
        np.arange(1, N + 1) + width + space,
        rgc_unq_norm, width,
        color=col_unq_rgc_all_dark, linewidth=bar_linewidth)
    bars_syn = plt.bar(np.arange(1, N + 1) + width + space, syn_norm, width,
                       bottom=rgc_unq_norm,
                       color=col_syn_dark, linewidth=bar_linewidth)
    plt.plot([x_min, x_max], [0.5, 0.5], '--', color=col_light_gray)

    ax = plt.gca()
    ax.set(xticks=(np.arange(1, N + 1) + width/2 + space/2),
           xticklabels=all_pairs, xlim=[x_min, x_max], ylim=[0, 1.1])
    plt.ylabel('$I\\, [a.u.]$')
    plt.xlabel('cell pair')
    plt.legend([bars_te, bars_unq_rgc_all, bars_syn],
               ['$\\langle lTE \\rangle$',
                '$I_{unq}(y_t;\\mathbf{x}^S)$',
                '$I_{syn}(y_t;\\mathbf{x}^S, \\mathbf{y}^S)$'],
               loc='upper center',
               bbox_to_anchor=(0.66, 1.30),
               fancybox=False, shadow=False, ncol=3,
               prop=fig_params['legend_prop'])

    plt.savefig(figurepath.joinpath(f'all_pairs_pid_te_pid_stacked.{fig_ext}'), dpi=600)
    plt.close()


# #############################################################################
#
# SPIKE-TRIGGERED AVERAGES
#
# #############################################################################
def plot_sta():

    print('\nPlotting STAs')
    # Get IDTxl results from random pair to access settings
    mte, _ = load_mte_ais_estimates(resultspath, n_pair=10)

    max_lag = mte.settings['max_lag_sources']
    sta_lais_all = np.zeros((N, max_lag * 2 + 1))
    sta_lte_all = np.zeros((N, max_lag * 2 + 1))
    sta_rgc_all = np.zeros((N, max_lag * 2 + 1))
    sta_lgn_all = np.zeros((N, max_lag * 2 + 1))
    sta_lais_relayed = np.zeros((N, max_lag * 2 + 1))
    sta_lte_relayed = np.zeros((N, max_lag * 2 + 1))
    sta_rgc_relayed = np.zeros((N, max_lag * 2 + 1))
    sta_lgn_relayed = np.zeros((N, max_lag * 2 + 1))
    sta_lais_nonrelayed = np.zeros((N, max_lag * 2 + 1))
    sta_lte_nonrelayed = np.zeros((N, max_lag * 2 + 1))
    sta_rgc_nonrelayed = np.zeros((N, max_lag * 2 + 1))
    sta_lgn_nonrelayed = np.zeros((N, max_lag * 2 + 1))

    for i, n_pair in enumerate(all_pairs):
        sta = np.load(resultspath.joinpath(f'pair_{n_pair:02d}_sta.npz'))

        # get all STAs
        sta_lais_all[i, :] = np.mean(sta['sta_lais'], axis=0)
        sta_lte_all[i, :] = np.mean(sta['sta_lte'], axis=0)
        sta_rgc_all[i, :] = np.mean(sta['sta_rgc'], axis=0)
        sta_lgn_all[i, :] = np.mean(sta['sta_lgn'], axis=0)

        # get STAs by relayed and non-relayed spikes
        relayed = sta['relayed']
        sta_lais_relayed[i, :] = np.mean(
            sta['sta_lais'][relayed, :], axis=0)
        sta_lte_relayed[i, :] = np.mean(
            sta['sta_lte'][relayed, :], axis=0)
        sta_rgc_relayed[i, :] = np.mean(
            sta['sta_rgc'][relayed, :], axis=0)
        sta_lgn_relayed[i, :] = np.mean(
            sta['sta_lgn'][relayed, :], axis=0)
        sta_lais_nonrelayed[i, :] = np.mean(
            sta['sta_lais'][np.invert(relayed), :], axis=0)
        sta_lte_nonrelayed[i, :] = np.mean(
            sta['sta_lte'][np.invert(relayed), :], axis=0)
        sta_rgc_nonrelayed[i, :] = np.mean(
            sta['sta_rgc'][np.invert(relayed), :], axis=0)
        sta_lgn_nonrelayed[i, :] = np.mean(
            sta['sta_lgn'][np.invert(relayed), :], axis=0)

    fig, ax = plt.subplots(nrows=4, ncols=4, figsize=(8.0, 6.0))
    ax = ax.flatten()
    plt.subplots_adjust(left=0.10, right=0.95, bottom=0.07, top=0.95, wspace=0.3, hspace=0.25)
    width = 0.5

    def _plot_sta(relayed, all, nonrelayed, col_light, col_dark, plot_inds,
                  label, barplot=False):
        # all
        a = ax[plot_inds[0]]
        a.plot(np.arange(-max_lag, max_lag + 1), all.T,
               color=col_light, linewidth=0.5)
        a.plot(np.arange(-max_lag, max_lag + 1), np.mean(all, axis=0),
               color=col_dark, linewidth=2)
        a.set(ylabel=f'{label} [bits]')

        # relayed
        a = ax[plot_inds[1]]
        a.plot(np.arange(-max_lag, max_lag + 1), relayed.T,
               color=col_light, linewidth=0.5)
        a.plot(np.arange(-max_lag, max_lag + 1), np.mean(relayed, axis=0),
               color=col_dark, linewidth=2)

        # nonrelayed
        a = ax[plot_inds[2]]
        a.plot(np.arange(-max_lag, max_lag + 1), nonrelayed.T,
               color=col_light, linewidth=0.5)
        a.plot(np.arange(-max_lag, max_lag + 1),
               np.mean(nonrelayed, axis=0),
               color=col_dark, linewidth=2)

        ymin, ymax = ax[plot_inds[1]].get_ylim()
        xmax = 15
        xmin = -xmax
        for a in ax[plot_inds[:3]]:
            a.set(ylim=[ymin, ymax], xlim=[xmin, xmax])
        # optional bar plot
        if barplot:
            a = ax[plot_inds[3]]
            bar_rel = a.bar(np.arange(1, N + 1), relayed[:, max_lag],
                            color=col_dark)
            bar_nonrel = a.bar(np.arange(1, N + 1) + width,
                               nonrelayed[:, max_lag], color=col_light)
            a.set(xticks=(np.arange(1, N + 1, 2) + width / 2),
                  xlim=[0, N + 1 + width],
                  xticklabels=np.array(all_pairs)[np.arange(1, N + 1, 2)])
            a.legend([bar_rel, bar_nonrel], ['rel.', 'non-rel.'])
        else:
            fig.delaxes(ax[plot_inds[2]+1])
            # ax[plot_inds[2]+1].axis('off')

    # LAIS
    _plot_sta(sta_lais_relayed, sta_lais_all, sta_lais_nonrelayed,
              col_lais_light, col_lais_dark, [0, 1, 2, 3], 'LAIS', True)
    # LTE
    _plot_sta(sta_lte_relayed, sta_lte_all, sta_lte_nonrelayed,
              col_lte_light, col_lte_dark, [4, 5, 6, 7], 'LTE', True)
    # RGC
    _plot_sta(sta_rgc_relayed, sta_rgc_all, sta_rgc_nonrelayed,
              col_rgc_light, col_rgc_dark, [8, 9, 10], 'RGC')
    # LGN
    _plot_sta(sta_lgn_relayed, sta_lgn_all, sta_lgn_nonrelayed,
              col_lgn_light, col_lgn_dark, [12, 13, 14], 'LGN')

    # Label subplots.
    enumerate_subplots(fig, 0.05, 0.85, text_size=subplot_label_size)
    plt.savefig(figurepath.joinpath(f'all_pairs_sta.{fig_ext}'), dpi=600)
    plt.close()


# #############################################################################
#
# INTER-SPIKE INTERVALS
#
# #############################################################################
def plot_isi():
    print('\nPlotting ISI results')
    max_isi = 40
    isi_counts = np.zeros(max_isi)
    lais_by_isi = np.zeros((N, max_isi))
    lte_by_isi = np.zeros((N, max_isi))
    isi_counts_relayed = np.zeros(max_isi)
    # isi_counts_nonrelayed = np.zeros(max_isi)
    lais_by_isi_relayed = np.zeros((N, max_isi))
    lte_by_isi_relayed = np.zeros((N, max_isi))
    lais_by_isi_nonrelayed = np.zeros((N, max_isi))
    lte_by_isi_nonrelayed = np.zeros((N, max_isi))

    for i, n_pair in enumerate(all_pairs):
        isi = np.load(resultspath.joinpath(f'pair_{n_pair:02d}_isi.npz'))

        isi_unique = isi['isi_unique'][isi['isi_unique'] < max_isi]
        isi_counts[isi_unique] += isi['isi_counts'][isi_unique]
        lais_by_isi[i, isi_unique] = isi['lais_by_isi'][isi_unique]
        lte_by_isi[i, isi_unique] = isi['lte_by_isi'][isi_unique]
        isi_counts_relayed[[isi_unique]] += isi['isi_counts_relayed'][isi_unique]

        isi_unique_relayed = isi['isi_unique_relayed'][
            isi['isi_unique_relayed'] < max_isi]
        lais_by_isi_relayed[i, isi_unique_relayed] = isi[
            'lais_by_isi_relayed'][isi_unique_relayed]
        lte_by_isi_relayed[i, isi_unique_relayed] = isi[
            'lte_by_isi_relayed'][isi_unique_relayed]
        isi_unique_nonrelayed = isi['isi_unique_nonrelayed'][
            isi['isi_unique_nonrelayed'] < max_isi]
        lais_by_isi_nonrelayed[i, isi_unique_nonrelayed] = isi[
            'lais_by_isi_nonrelayed'][isi_unique_nonrelayed]
        lte_by_isi_nonrelayed[i, isi_unique_nonrelayed] = isi[
            'lte_by_isi_nonrelayed'][isi_unique_nonrelayed]

    plt.rc('axes', titlesize=12, labelsize=10, titleweight='bold',
           linewidth=axes_linewidth)

    fig = plt.figure(figsize=(fig_params['fig_width'], 6.0))
    isi_ind = np.arange(max_isi)
    plt.subplots_adjust(left=0.11, right=0.97, bottom=0.07, top=0.95, wspace=0.3, hspace=0.4)

    # ISI distribution
    ax = plt.subplot(321)  # all
    ax.bar(np.arange(max_isi), isi_counts, color=col_light_gray, linewidth=0.5)
    ax.set(xlabel='$ISI$ [ms]', ylabel='abs. frequency')
    ax = plt.subplot(322)  # relayed
    ax.bar(np.arange(max_isi), isi_counts_relayed,
           color=col_dark_gray, linewidth=0.5)
    ax.set(xlabel='$ISI_{rel}$ [ms]', ylabel='abs. frequency')

    def _plot_line_area(ax, measures, col_dark, col_light, label, legend,
                        linestyle=None):
        if linestyle is None:
            linestyle = ['-']
        for i, measure in enumerate(measures):
            print('positive {0}: {1}'.format(
                legend[i], isi_ind[np.mean(measure, axis=0) > 0]))
            ax.plot(isi_ind, np.mean(measure, axis=0), linestyle[i],
                    label=legend[i], color=col_dark, linewidth=2.0)
            ax.fill_between(isi_ind,
                            np.mean(measure, axis=0) + np.std(measure, axis=0),
                            np.mean(measure, axis=0) - np.std(measure, axis=0),
                            facecolor=col_light, alpha=0.4)
        y_min, y_max = ax.get_ylim()
        y_max *= 1.1
        for i, measure in enumerate(measures):
            measure_max = isi_ind[np.argmax(np.mean(measure, axis=0))]
            plt.plot([measure_max, measure_max], [y_min, y_max], '--',
                     color=col_light_gray)
            plt.text(measure_max * 1.2, y_max * (1-(i+1)*0.25),
                     'max. @ ISI = {0:d}'.format(measure_max), fontsize=10)
            print(f'max. {legend[i]}: {measure_max}')

        ax.set(xlabel='$ISI$ [ms]', ylabel=f'{label} [bits]',
               xlim=[-0.5, max_isi], ylim=[y_min, y_max])
        # plt.title(f'{label} by ISI', y=title_offset)
        plt.legend(loc='lower right')

    # LAIS and LTE by ISI, total
    ax = plt.subplot(323)
    _plot_line_area(ax, [lais_by_isi], col_lais_dark, col_lais_light, '$lAIS$', ['mean $lAIS$'])
    ax = plt.subplot(324)
    _plot_line_area(ax, [lte_by_isi], col_lte_dark, col_lte_light, '$lTE$', ['mean $lTE$'])

    # LAIS and LTE by ISI, relayed vs. non-relayed
    ax = plt.subplot(325)
    _plot_line_area(ax, [lais_by_isi_relayed, lais_by_isi_nonrelayed],
                    col_lais_dark, col_lais_light, '$lAIS$',
                    ['mean $lAIS$ relayed', 'mean $lAIS$ nonrelayed'], ['--', ':'])
    ax = plt.subplot(326)
    _plot_line_area(ax, [lte_by_isi_relayed, lte_by_isi_nonrelayed],
                    col_lte_dark, col_lte_light, '$lTE$',
                    ['mean $lTE$ relayed', 'mean $lTE$ nonrelayed'], ['--', ':'])

    # Label subplots for paper
    enumerate_subplots(fig, -0.22, 1.05, text_size=subplot_label_size)
    plt.savefig(figurepath.joinpath(f'all_pairs_isi.{fig_ext}'), dpi=600)
    plt.close()


# #############################################################################
#
# SPIKE-TRIGGERED AVERAGES FOR TUPLES
#
# #############################################################################
def plot_tuples():
    print('\nPlotting STAs for spike tuples')
    max_lag = 20  # this is one sample more than the maximum TE target embedding
    tuples_lais_all = np.zeros((N, max_lag * 2 + 1))
    tuples_lte_all = np.zeros((N, max_lag * 2 + 1))
    tuples_lais_relayed = np.zeros((N, max_lag * 2 + 1))
    tuples_lte_relayed = np.zeros((N, max_lag * 2 + 1))
    tuples_lais_nonrelayed = np.zeros((N, max_lag * 2 + 1))
    tuples_lte_nonrelayed = np.zeros((N, max_lag * 2 + 1))

    tuples_lais_by_isi = {
        0: np.zeros((N, max_lag * 2 + 1)),
        1: np.zeros((N, max_lag * 2 + 1)),
        2: np.zeros((N, max_lag * 2 + 1)),
        3: np.zeros((N, max_lag * 2 + 1)),
        4: np.zeros((N, max_lag * 2 + 1)),
        5: np.zeros((N, max_lag * 2 + 1)),
        6: np.zeros((N, max_lag * 2 + 1)),
        7: np.zeros((N, max_lag * 2 + 1)),
        8: np.zeros((N, max_lag * 2 + 1)),
        9: np.zeros((N, max_lag * 2 + 1)),
        10: np.zeros((N, max_lag * 2 + 1))
    }
    tuples_lte_by_isi = {
        0: np.zeros((N, max_lag * 2 + 1)),
        1: np.zeros((N, max_lag * 2 + 1)),
        2: np.zeros((N, max_lag * 2 + 1)),
        3: np.zeros((N, max_lag * 2 + 1)),
        4: np.zeros((N, max_lag * 2 + 1)),
        5: np.zeros((N, max_lag * 2 + 1)),
        6: np.zeros((N, max_lag * 2 + 1)),
        7: np.zeros((N, max_lag * 2 + 1)),
        8: np.zeros((N, max_lag * 2 + 1)),
        9: np.zeros((N, max_lag * 2 + 1)),
        10: np.zeros((N, max_lag * 2 + 1))
    }

    for i, n_pair in enumerate(all_pairs):
        sta = np.load(resultspath.joinpath(f'pair_{n_pair:02d}_tuple.npz'))

        # get all STAs
        tuples_lais_all[i, :] = np.mean(sta['sta_lais'], axis=0)
        tuples_lte_all[i, :] = np.mean(sta['sta_lte'], axis=0)

        # get STAs by relayed and non-relayed spikes
        relayed = sta['relayed']
        tuples_lais_relayed[i, :] = np.mean(
            sta['sta_lais'][relayed, :], axis=0)
        tuples_lte_relayed[i, :] = np.mean(
            sta['sta_lte'][relayed, :], axis=0)
        tuples_lais_nonrelayed[i, :] = np.mean(
            sta['sta_lais'][np.invert(relayed), :], axis=0)
        tuples_lte_nonrelayed[i, :] = np.mean(
            sta['sta_lte'][np.invert(relayed), :], axis=0)

        for isi in range(11):
            tuples_lais_by_isi[isi][i, :] = np.mean(sta['sta_lais'][sta['isi'] == isi, :], axis=0)
            tuples_lte_by_isi[isi][i, :] = np.mean(sta['sta_lte'][sta['isi'] == isi, :], axis=0)

    ylim = [np.inf, -np.inf]
    fig_isi, ax_isi = plt.subplots(
        nrows=10, ncols=2, figsize=(fig_params['fig_width'], 6))
    plt.subplots_adjust(
        left=0.10, right=0.95, bottom=0.15, top=0.95, wspace=0.3, hspace=0)
    for isi, a in zip(range(1, 11), ax_isi):
        time_ind = np.arange(-max_lag, max_lag + 1)
        a[0].fill_between(time_ind,
                          np.nanmean(tuples_lais_by_isi[isi], axis=0) + np.std(tuples_lais_by_isi[isi], axis=0),
                          np.nanmean(tuples_lais_by_isi[isi], axis=0) - np.std(tuples_lais_by_isi[isi], axis=0),
                          facecolor=col_lais_light, alpha=0.4)
        a[0].plot(time_ind, np.nanmean(tuples_lais_by_isi[isi], axis=0),
                  color=col_lais_dark, linewidth=2)
        if isi > 2:
            ylim[0] = np.min([ylim[0], a[0].get_ylim()[0]])
            ylim[1] = np.max([ylim[1], a[0].get_ylim()[1]])
        a[1].fill_between(time_ind,
                          np.nanmean(tuples_lte_by_isi[isi], axis=0) + np.std(tuples_lte_by_isi[isi], axis=0),
                          np.nanmean(tuples_lte_by_isi[isi], axis=0) - np.std(tuples_lte_by_isi[isi], axis=0),
                          facecolor=col_lte_light, alpha=0.4)
        a[1].plot(time_ind, np.nanmean(tuples_lte_by_isi[isi], axis=0),
                  color=col_lte_dark, linewidth=2)
        a[0].axvline(0, color='lightgray', ls='--', zorder=0)
        a[0].axvline(isi, color='lightgray', ls='--', zorder=0)
        a[1].axvline(0, color='lightgray', ls='--', zorder=0)
        a[1].axvline(isi, color='lightgray', ls='--', zorder=0)
        a[0].axhline(0, color='gray', lw=0.7, zorder=0)
        a[1].axhline(0, color='gray', lw=0.7, zorder=0)
        a[0].text(
            0.03, 0.68,
            f'ISI = {isi}',
            bbox=dict(
                fc='w',
                alpha=0.7,
                ec='w',
                boxstyle='square,pad=0.1'
            ),
            transform=a[0].transAxes
        )
        if isi < 10:
            a[0].set(xticklabels=[])
            a[1].set(xticklabels=[])
    for a in ax_isi[2:, 0]:
        a.set(ylim=ylim)
    ax_isi[-1, 0].set(ylabel='$lAIS$', xlabel='$t$ [ms]')
    ax_isi[-1, 1].set(ylabel='$lTE$', xlabel='$t$ [ms]')
    savename = figurepath.joinpath(f'all_pairs_tuples_indiv.{fig_ext}')
    print(f'Saving figure to\n{savename}')
    plt.savefig(savename, dpi=600)
    plt.close()

    fig, ax = plt.subplots(
        nrows=2, ncols=3, figsize=(fig_params['fig_width'], 3))
    ax = ax.flatten()
    plt.subplots_adjust(
        left=0.10, right=0.95, bottom=0.15, top=0.95, wspace=0.3, hspace=0.25)

    def _plot_sta(relayed, all, nonrelayed, col_light, col_dark, plot_inds,
                  label):
        time_ind = np.arange(-max_lag, max_lag + 1)
        baseline = np.mean(all[:max_lag])
        # relayed
        a = ax[plot_inds[1]]
        a.fill_between(time_ind,
                       np.mean(relayed, axis=0) + np.std(relayed, axis=0),
                       np.mean(relayed, axis=0) - np.std(relayed, axis=0),
                       facecolor=col_light, alpha=0.4)
        a.plot(time_ind, np.mean(relayed, axis=0),
               color=col_dark, linewidth=2)
        print('{} - Mean relayed positive: {}'.format(
            label, time_ind[np.mean(relayed, axis=0) > baseline]))
        print('{} - Max relayed: {}'.format(
            label, time_ind[np.argmax(np.mean(relayed, axis=0))]))

        ymin, ymax = a.get_ylim()
        # all
        a = ax[plot_inds[0]]
        a.fill_between(time_ind,
                       np.mean(all, axis=0) + np.std(all, axis=0),
                       np.mean(all, axis=0) - np.std(all, axis=0),
                       facecolor=col_light, alpha=0.4)
        a.plot(time_ind, np.mean(all, axis=0),
               color=col_dark, linewidth=2)
        a.set(ylim=[ymin, ymax], ylabel=f'{label} [bits]')
        print('{} - Mean all positive: {}'.format(
            label, time_ind[np.mean(all, axis=0) > baseline]))
        print('{} - Max all: {}'.format(
            label, time_ind[np.argmax(np.mean(all, axis=0))]))

        # nonrelayed
        a = ax[plot_inds[2]]
        a.fill_between(
            time_ind,
            np.mean(nonrelayed, axis=0) + np.std(nonrelayed, axis=0),
            np.mean(nonrelayed, axis=0) - np.std(nonrelayed, axis=0),
            facecolor=col_light, alpha=0.4)
        a.plot(time_ind,
               np.mean(nonrelayed, axis=0),
               color=col_dark, linewidth=2)
        a.set_ylim(ymin, ymax)
        print('{} - Mean non-relayed positive: {}'.format(
            label, time_ind[np.mean(nonrelayed, axis=0) > baseline]))
        print('{} - Max non-relayed: {}'.format(
            label, time_ind[np.argmax(np.mean(nonrelayed, axis=0))]))

        return ax

    # LAIS
    _plot_sta(tuples_lais_relayed, tuples_lais_all, tuples_lais_nonrelayed,
              col_lais_light, col_lais_dark, [0, 1, 2], '$lAIS$')
    # LTE
    ax = _plot_sta(tuples_lte_relayed, tuples_lte_all, tuples_lte_nonrelayed,
                   col_lte_light, col_lte_dark, [3, 4, 5], '$lTE$')
    for a in ax:
        a.set(xlabel='$t$ $[ms]$')

    # Label subplots for paper
    enumerate_subplots(fig, 0.03, 0.85, text_size=subplot_label_size)
    plt.savefig(figurepath.joinpath(f'all_pairs_tuples.{fig_ext}'), dpi=600)
    plt.close()


# #############################################################################
#
# PLOT EXAMPLE OF lSTC correlations
#
# #############################################################################
def plot_lstc_corr_example():
    contribution = np.genfromtxt(datapath.joinpath('contr.csv'), delimiter=',')
    pairs = [12, 15, 10, 11]  # Examples with high and low contribution

    print('\nPlotting LSTC scatter plots for example pairs ', pairs)

    n_bins = 15
    fig, ax = plt.subplots(nrows=len(pairs), ncols=3, figsize=(7.48, 7))

    p = 0
    for pair in pairs:

        print(f'Plotting example pair {pair}')
        f = np.load(resultspath.joinpath(f'pair_{pair:02d}_hist_data.npz'))
        lais = f['lais']
        lte = f['lte']
        rgc_spike_ind = f['rgc_spike_ind']
        lgn_spike_ind = f['lgn_spike_ind']
        relayed = np.logical_and(rgc_spike_ind, lgn_spike_ind)
        nonrelayed = np.logical_and(rgc_spike_ind, np.invert(lgn_spike_ind))

        # All RGC spikes
        hist, xedges, yedges, h = ax[p, 0].hist2d(
            lais[rgc_spike_ind.astype(bool)],
            lte[rgc_spike_ind.astype(bool)],
            bins=n_bins,
            cmap='Greys',
            norm=mlp.colors.LogNorm())
        cb = plt.colorbar(h, ax=ax[p, 0])
        # cb.set_label('counts [log]')
        c = np.corrcoef(lais, lte)[0, 1]
        contrib = contribution[pair-1]
        ax[p, 0].text(0.05, 0.56, f'Pair {pair}\n$contr={contrib:.2f}$ %\n$c={c:.4f}$', transform=ax[p, 0].transAxes)

        # Relayed spikes
        hist, xedges, yedges, h = ax[p, 1].hist2d(
            lais[relayed],
            lte[relayed],
            bins=n_bins,
            cmap=clr.LinearSegmentedColormap.from_list("", ["w", "#4682b4", "k"], N=256),  # Blue
            norm=mlp.colors.LogNorm())
        cb = plt.colorbar(h, ax=ax[p, 1])

        # Non-relayed spikes
        hist, xedges, yedges, h = ax[p, 2].hist2d(
            lais[nonrelayed],
            lte[nonrelayed],
            bins=n_bins,
            cmap=clr.LinearSegmentedColormap.from_list("", ["w", "#cd5c5c", "k"], N=256),  # Red
            norm=mlp.colors.LogNorm())
        cb = plt.colorbar(h, ax=ax[p, 2])
        cb.set_label('counts [log]')

        # Axis settings
        xlim = ax[p, 0].get_xlim()
        ylim = ax[p, 0].get_ylim()
        for a in ax[p, :]:
            a.set(xlim=xlim, ylim=ylim, xlabel='LAIS', ylabel='LTE')
            a.axhline(0, c='k', ls='--', alpha=0.5)
            a.axvline(0, c='k', ls='--', alpha=0.5)
        p += 1

    plt.tight_layout()
    plt.savefig(figurepath.joinpath('examples_lstc_corr_hist_high_low.pdf'), dpi=400)
    plt.close('all')


if __name__ == '__main__':
    embedding_results()
    lstc_correlation()
    plot_pid_all()
    plot_isi()
    plot_tuples()
    plot_sta()
    plot_lstc_corr_example()
